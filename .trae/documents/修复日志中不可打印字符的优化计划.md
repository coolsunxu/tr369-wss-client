# 修复日志中不可打印字符的优化计划

## 问题分析

日志中出现 `u00031.0` 等不可打印字符，这是因为：
1. payload是二进制数据（如Protobuf序列化后的数据）
2. 当前的`formatPayload`函数尝试将其解析为JSON，失败后直接转换为字符串
3. 二进制数据中的特殊字符在日志中显示为Unicode转义序列，影响可读性

## 优化方案

### 1. 改进formatPayload函数

修改`formatPayload`函数，使其能够正确处理二进制数据：

```go
func formatPayload(payload []byte) string {
    // 尝试解析为JSON对象
    var jsonObj interface{}
    if err := json.Unmarshal(payload, &jsonObj); err == nil {
        // 如果是JSON对象，格式化输出
        if formatted, err := json.MarshalIndent(jsonObj, "", "  "); err == nil {
            return string(formatted)
        }
    }
    
    // 如果不是JSON对象或解析失败，尝试解析为JSON数组
    var jsonArray []interface{}
    if err := json.Unmarshal(payload, &jsonArray); err == nil {
        // 如果是JSON数组，格式化输出
        if formatted, err := json.MarshalIndent(jsonArray, "", "  "); err == nil {
            return string(formatted)
        }
    }
    
    // 检查是否为可打印的字符串
    if isPrintable(string(payload)) {
        return string(payload)
    }
    
    // 如果不是可打印字符串，转换为十六进制编码
    return fmt.Sprintf("hex:%x", payload)
}

// isPrintable checks if a string is printable
func isPrintable(s string) bool {
    for _, r := range s {
        if !unicode.IsPrint(r) {
            return false
        }
    }
    return true
}
```

### 2. 添加必要的导入

在`client/client.go`文件中添加`unicode`导入：

```go
import (
    // 其他导入
    "unicode"
)
```

### 3. 优化优势

1. **可读性**：避免日志中出现不可打印字符和Unicode转义序列
2. **安全性**：确保日志只包含可打印字符
3. **完整性**：通过十六进制编码保留原始数据的完整性
4. **智能处理**：自动检测并处理不同类型的数据

### 4. 实施步骤

1. **添加unicode导入**：在`client/client.go`文件中添加`unicode`导入
2. **添加isPrintable辅助函数**：用于检查字符串是否可打印
3. **修改formatPayload函数**：实现改进的格式化逻辑
4. **验证日志输出**：确保优化后的日志不再包含不可打印字符

## 预期效果

优化后的日志将不再包含不可打印字符和Unicode转义序列，二进制数据将以十六进制编码形式呈现，便于阅读和调试。