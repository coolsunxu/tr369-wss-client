# payload JSON格式化日志打印优化计划

## 优化需求

将 `logger.Infof("Sending message: %s", string(payload))` 等日志中的payload打印为JSON字符串输出，同时保持使用Infof格式。

## 优化方案

### 1. 具体优化点

- **位置**：`client/client.go:216` 和 `client/client.go:229`
- **当前代码**：
  ```go
  logger.Infof("Sending message: %s", string(payload))
  logger.Infof("Send message success %v", string(payload))
  ```
- **优化后代码**：
  ```go
  logger.Infof("Sending message: %s", formatPayload(payload))
  logger.Infof("Send message success: %s", formatPayload(payload))
  ```

### 2. 添加格式化函数

在 `client/client.go` 文件中添加 `formatPayload` 函数，用于将二进制payload转换为JSON字符串：

```go
func formatPayload(payload []byte) string {
    // 尝试解析为JSON对象
    var jsonObj interface{}
    if err := json.Unmarshal(payload, &jsonObj); err == nil {
        // 如果是JSON对象，格式化输出
        if formatted, err := json.MarshalIndent(jsonObj, "", "  "); err == nil {
            return string(formatted)
        }
    }
    
    // 如果不是JSON对象或解析失败，尝试解析为JSON数组
    var jsonArray []interface{}
    if err := json.Unmarshal(payload, &jsonArray); err == nil {
        // 如果是JSON数组，格式化输出
        if formatted, err := json.MarshalIndent(jsonArray, "", "  "); err == nil {
            return string(formatted)
        }
    }
    
    // 如果不是JSON，返回原始字符串
    return string(payload)
}
```

### 3. 优化优势

1. **保持Infof格式**：满足用户要求，继续使用Infof函数
2. **JSON格式化输出**：将payload转换为美观的JSON字符串
3. **智能处理**：自动检测并处理JSON对象、数组和普通字符串
4. **可读性**：格式化的JSON便于阅读和调试
5. **统一格式**：所有消息日志采用相同的格式

### 4. 实施步骤

1. **添加必要的导入**：在 `client/client.go` 文件中添加 `encoding/json` 导入
2. **添加formatPayload函数**：实现payload格式化逻辑
3. **修改日志打印语句**：在Infof中使用formatPayload函数处理payload
4. **验证日志输出**：确保优化后的日志格式正确，JSON字符串美观易读

### 5. 扩展优化

可以考虑在其他类似的日志打印位置应用相同的优化方案，如接收消息时的日志打印，以保持日志格式的一致性。

## 预期效果

优化后的日志将保持使用Infof格式，但payload将被格式化为美观的JSON字符串输出，便于阅读和调试。对于非JSON数据，将直接输出原始字符串，确保兼容性。